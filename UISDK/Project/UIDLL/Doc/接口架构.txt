
背景：

    在ui_dll_version版本中采用的是将所有的类完全导出，这样有几个缺陷：
        a. dll导出数据过多，导出列表不清晰。 导出过多的数据对DLL大小有多少影响目前尚未验证
        b. 如果一个导出类中包含了stl类，(如string)，在跨模块继承时，很容易造成崩溃现象
        c. 对外暴露的信息太多，不利于升级
        d. 导出太多的头文件，一修改导出类的一些成员时，就得全部编译
		
目标：
    1. 只对象暴露接口和若干方法
    2. 要求可以扩展内部对象，实现继承的效果
    
架构：

   
----> 新 Pimpl 架构： http://stackoverflow.com/questions/4253441/how-to-use-an-exported-class-declspecdllexportin-an-stl-template
      Pimpl能够解决类内部信息隐藏问题。但是它不能像纯虚函数一样，不用导出类定义。Pimpl仍然需要使用dllexport ... 
   
众多ProcessMessage函数的意义：
public:            IMessage::ProcessMessage         : 就是它会被UISendMessage所调用。该函数采用NVI规则，内部再调用私有虚函数Ixxx::virtualProcessMessage
private, virtual   Ixxx::virtualProcessMessage      ：唯一一个虚函数，用于各个接口类去实现多态
public:            Ixxx::nvProcessMessage           ：用于在子类中直接调用相应父类的方法，而这个特性被多态给毁了，因此另外增加了一个函数
public:            xxx::innerVirtualProcessMessage  ：用于内部类直接从Message派生时的消息映射
public:            xxx::nvProcessMessage            : UI_BEGIN_MESSAGE中的函数，由Ixxx负责调用，内部会再调用xxProcessMessage方法

Ixxx::nvProcessMessage和xxx::nvProcessMessage保持同名是为了在UI_CHAIN_MSG_MAP的时候即可以传Ixxx，也可以传xxx


2. 没法实现跨过一个父类，调用父父类的方法。例如：Button::ProcessMessage 要调用Object::ProcessMessage，中间隔了一个Control::PorcessMessage，
   怎么办？
   20130321.09.26 再增加了一个nvProcessMessage非虚函数，这样就能通过指针直接调用相应类的方法了
   
遗留问题：
   
   
4. 各个模块之间如何避免消息定义的值重复了？例如模块A定义 UI_WM_CLICK1  2001;  模块B定义 UI_WM_CLICK2 2001;，这就出现问题了
   fix. 用时间进行定义，如 130312112，表示13年10月31日21点12分

5. 像RenderBase/TextRenderBase之类的，将DrawState做成ProcessMessasge来处理，是不是有点太慢了？要不要考虑直接做成新的虚函数？

6. ILayout如何扩展

一些有用的代码：
    http://tortoisesvn.googlecode.com/svn/trunk/src/Utils